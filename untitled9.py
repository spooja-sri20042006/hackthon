# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPVGnkItrgVlmUTabuPhf-DDZS01CqdB
"""

# AI Audiobook Creator - Fixed Audio with Clear Speech
# Designed for Google Colab with Gradio Interface

import gradio as gr
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
import requests
import json
import base64
import io
import os
import zipfile
from datetime import datetime
import re
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import tempfile
import wave
import pyttsx3
from gtts import gTTS
import pygame
from pydub import AudioSegment
from pydub.playback import play
import threading
import time

# ============================================================================
# INSTALLATION COMMANDS FOR GOOGLE COLAB (Run these first)
# ============================================================================
"""
!pip install gradio transformers torch pillow requests numpy
!pip install pyttsx3 gtts pygame pydub
!apt-get update &> /dev/null
!apt-get install espeak espeak-data libespeak1 libespeak-dev
!apt-get install festival festvox-kallpc16k
!pip install TTS
"""

# ============================================================================
# CONFIGURATION AND SETUP
# ============================================================================

class Config:
    # Model Configuration
    MODEL_NAME = "microsoft/DialoGPT-small"  # More reliable model

    # Voice Options with TTS engines
    VOICES = {
        "Lisa": {"engine": "gtts", "lang": "en", "tld": "us"},
        "Michael": {"engine": "pyttsx3", "voice_id": 0},
        "Allison": {"engine": "gtts", "lang": "en", "tld": "co.uk"}
    }

    # Language Support
    LANGUAGES = {
        "English": "en",
        "Spanish": "es",
        "French": "fr",
        "German": "de",
        "Italian": "it"
    }

# ============================================================================
# IMPROVED TEXT-TO-SPEECH CLASS WITH CLEAR SPEECH
# ============================================================================

class ClearSpeechTTS:
    def __init__(self):
        self.pyttsx3_engine = None
        self.init_pyttsx3()

    def init_pyttsx3(self):
        """Initialize pyttsx3 engine"""
        try:
            self.pyttsx3_engine = pyttsx3.init()
            # Set properties for clear speech
            self.pyttsx3_engine.setProperty('rate', 150)  # Speed of speech
            self.pyttsx3_engine.setProperty('volume', 0.9)  # Volume level
        except Exception as e:
            print(f"pyttsx3 initialization error: {e}")

    def synthesize_speech_gtts(self, text, lang="en", tld="com", speed=0):
        """Generate speech using Google Text-to-Speech"""
        try:
            # Adjust speed by modifying text (simple approach)
            if speed > 0:
                # Add pauses for slower speech
                text = text.replace('.', '... ')
                text = text.replace(',', ', ')
            elif speed < 0:
                # Remove some pauses for faster speech
                text = text.replace('  ', ' ')

            # Generate speech
            tts = gTTS(text=text, lang=lang, tld=tld, slow=False)

            # Save to temporary file
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.mp3')
            tts.save(temp_file.name)

            # Convert to WAV for better compatibility
            audio = AudioSegment.from_mp3(temp_file.name)
            wav_file = tempfile.NamedTemporaryFile(delete=False, suffix='.wav')
            audio.export(wav_file.name, format="wav")

            # Clean up temp MP3
            os.unlink(temp_file.name)

            return wav_file.name

        except Exception as e:
            print(f"GTTS Error: {e}")
            return self.fallback_speech_generation(text)

    def synthesize_speech_pyttsx3(self, text, voice_id=0, rate=150, pitch=0):
        """Generate speech using pyttsx3"""
        try:
            if not self.pyttsx3_engine:
                self.init_pyttsx3()

            # Set voice properties
            voices = self.pyttsx3_engine.getProperty('voices')
            if voices and len(voices) > voice_id:
                self.pyttsx3_engine.setProperty('voice', voices[voice_id].id)

            # Adjust rate based on speed parameter
            adjusted_rate = max(50, min(300, rate + (rate * 0.01 * pitch)))
            self.pyttsx3_engine.setProperty('rate', adjusted_rate)

            # Create temporary file
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.wav')
            temp_file.close()

            # Save speech to file
            self.pyttsx3_engine.save_to_file(text, temp_file.name)
            self.pyttsx3_engine.runAndWait()

            # Wait a moment for file to be written
            time.sleep(0.5)

            if os.path.exists(temp_file.name) and os.path.getsize(temp_file.name) > 0:
                return temp_file.name
            else:
                return self.fallback_speech_generation(text)

        except Exception as e:
            print(f"pyttsx3 Error: {e}")
            return self.fallback_speech_generation(text)

    def synthesize_speech(self, text, voice="Lisa", speed=0, pitch=0, language="en"):
        """Main speech synthesis method"""
        if not text or not text.strip():
            return self.fallback_speech_generation("No text provided")

        # Clean text for better speech
        text = self.clean_text_for_speech(text)

        voice_config = Config.VOICES.get(voice, Config.VOICES["Lisa"])

        try:
            if voice_config["engine"] == "gtts":
                return self.synthesize_speech_gtts(
                    text,
                    voice_config["lang"],
                    voice_config.get("tld", "com"),
                    speed
                )
            elif voice_config["engine"] == "pyttsx3":
                return self.synthesize_speech_pyttsx3(
                    text,
                    voice_config.get("voice_id", 0),
                    150 + speed,
                    pitch
                )
            else:
                return self.fallback_speech_generation(text)

        except Exception as e:
            print(f"Speech synthesis error: {e}")
            return self.fallback_speech_generation(text)

    def clean_text_for_speech(self, text):
        """Clean text for better speech synthesis"""
        # Remove excessive whitespace
        text = re.sub(r'\s+', ' ', text)

        # Fix common issues
        text = text.replace('&', ' and ')
        text = text.replace('@', ' at ')
        text = text.replace('#', ' number ')
        text = text.replace('%', ' percent ')

        # Add proper pauses
        text = text.replace('.', '. ')
        text = text.replace(',', ', ')
        text = text.replace(';', '; ')
        text = text.replace(':', ': ')

        # Remove extra spaces
        text = re.sub(r'\s+', ' ', text).strip()

        return text

    def fallback_speech_generation(self, text):
        """Fallback method using system TTS"""
        try:
            # Try using espeak if available
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.wav')
            temp_file.close()

            # Use espeak command line tool
            import subprocess
            result = subprocess.run([
                'espeak',
                '-w', temp_file.name,
                '-s', '150',  # Speed
                '-a', '100',  # Amplitude
                text
            ], capture_output=True, text=True)

            if result.returncode == 0 and os.path.exists(temp_file.name):
                return temp_file.name
            else:
                return self.create_simple_beep_audio(text)

        except Exception as e:
            print(f"Fallback TTS error: {e}")
            return self.create_simple_beep_audio(text)

    def create_simple_beep_audio(self, text):
        """Create simple audio as last resort"""
        duration = max(len(text) * 0.1, 2.0)
        sample_rate = 22050

        # Create more speech-like audio with multiple tones
        t = np.linspace(0, duration, int(duration * sample_rate), False)

        # Generate speech-like frequencies
        frequencies = [200, 300, 400, 500, 300, 200]  # Simulate speech patterns
        audio_data = np.zeros_like(t)

        segment_length = len(t) // len(frequencies)
        for i, freq in enumerate(frequencies):
            start = i * segment_length
            end = start + segment_length
            if end > len(t):
                end = len(t)

            # Add speech-like modulation
            envelope = np.sin(2 * np.pi * 5 * t[start:end])  # 5 Hz modulation
            carrier = np.sin(2 * np.pi * freq * t[start:end])
            audio_data[start:end] = envelope * carrier * 0.3

        # Convert to 16-bit PCM
        audio_data = (audio_data * 32767).astype(np.int16)

        # Create WAV file
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.wav')
        with wave.open(temp_file.name, 'wb') as wav_file:
            wav_file.setnchannels(1)
            wav_file.setsampwidth(2)
            wav_file.setframerate(sample_rate)
            wav_file.writeframes(audio_data.tobytes())

        return temp_file.name

# ============================================================================
# IMPROVED TEXT REWRITING CLASS
# ============================================================================

class GraniteTextRewriter:
    def __init__(self):
        self.model = None
        self.tokenizer = None
        self.load_model()

    def load_model(self):
        try:
            print("Loading text rewriting model...")
            self.tokenizer = AutoTokenizer.from_pretrained(Config.MODEL_NAME)
            self.model = AutoModelForCausalLM.from_pretrained(
                Config.MODEL_NAME,
                torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32
            )
            print("Model loaded successfully!")
        except Exception as e:
            print(f"Model loading error: {e}")
            self.model = None
            self.tokenizer = None

    def rewrite_text(self, text, tone="Neutral", preserve_meaning=True):
        """Rewrite text with specified tone"""
        if not text or not text.strip():
            return text

        # Simple rule-based rewriting if model fails
        if not self.model or not self.tokenizer:
            return self._rule_based_rewrite(text, tone)

        try:
            tone_prompts = {
                "Neutral": "Rewrite this text in a clear, neutral tone:",
                "Suspenseful": "Rewrite this text with suspense and drama:",
                "Inspiring": "Rewrite this text in an inspiring, motivational way:"
            }

            prompt = f"{tone_prompts.get(tone, tone_prompts['Neutral'])}\n\n{text}\n\nRewritten:"

            inputs = self.tokenizer.encode(prompt, return_tensors="pt", max_length=512, truncation=True)

            with torch.no_grad():
                outputs = self.model.generate(
                    inputs,
                    max_length=inputs.shape[1] + 100,
                    num_return_sequences=1,
                    temperature=0.7,
                    do_sample=True,
                    pad_token_id=self.tokenizer.eos_token_id,
                    eos_token_id=self.tokenizer.eos_token_id
                )

            generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
            rewritten = generated_text.split("Rewritten:")[-1].strip()

            return rewritten if len(rewritten) > 10 else self._rule_based_rewrite(text, tone)

        except Exception as e:
            print(f"AI rewriting error: {e}")
            return self._rule_based_rewrite(text, tone)

    def _rule_based_rewrite(self, text, tone):
        """Fallback rule-based text rewriting"""
        if tone == "Suspenseful":
            # Add suspenseful elements
            sentences = text.split('.')
            rewritten_sentences = []
            for sentence in sentences:
                if sentence.strip():
                    rewritten_sentences.append(sentence.strip() + "...")
            return " ".join(rewritten_sentences)

        elif tone == "Inspiring":
            # Add inspiring elements
            inspiring_phrases = [
                "Remarkably, ", "Incredibly, ", "Amazingly, ",
                "With great determination, ", "Against all odds, "
            ]
            sentences = text.split('.')
            rewritten_sentences = []
            for i, sentence in enumerate(sentences):
                if sentence.strip():
                    if i % 2 == 0 and i < len(inspiring_phrases):
                        rewritten_sentences.append(inspiring_phrases[i % len(inspiring_phrases)] + sentence.strip().lower())
                    else:
                        rewritten_sentences.append(sentence.strip())
            return ". ".join(rewritten_sentences) + "."

        return text  # Neutral tone - return as is

# ============================================================================
# IMPROVED MAIN APPLICATION CLASS
# ============================================================================

class AudiobookCreatorApp:
    def __init__(self):
        self.rewriter = GraniteTextRewriter()
        self.tts = ClearSpeechTTS()
        self.current_audio = None
        self.current_chapters = []

    def process_text_input(self, input_text, uploaded_file, tone, voice, speed, pitch,
                          language, add_music, emotion_mode, summarize_mode):
        """Main processing function with clear speech output"""

        try:
            # Get text from input or file
            if uploaded_file is not None:
                text = uploaded_file.decode('utf-8')
            else:
                text = input_text

            if not text or not text.strip():
                return "‚ùå Please provide text input or upload a file.", "", None, None, None

            # Limit text length for demo
            if len(text) > 1000:
                text = text[:1000] + "..."

            print(f"Processing text: {text[:100]}...")

            # Summarize if requested
            if summarize_mode:
                text = self.summarize_text(text)

            # Rewrite text based on tone
            print(f"Rewriting text with tone: {tone}")
            rewritten_text = self.rewriter.rewrite_text(text, tone)

            # Generate speech audio
            print(f"Generating speech with voice: {voice}")
            audio_file_path = self.tts.synthesize_speech(
                rewritten_text,
                voice=voice,
                speed=speed,
                pitch=pitch,
                language=Config.LANGUAGES.get(language, "en")
            )

            if not audio_file_path or not os.path.exists(audio_file_path):
                return "‚ùå Failed to generate speech audio.", "", None, None, None

            print(f"Audio generated: {audio_file_path}")
            self.current_audio = audio_file_path

            # Create comparison text
            comparison = f"""
**Original Text:**
{text}

**Rewritten Text ({tone} Tone):**
{rewritten_text}

**Speech Settings:**
- Voice: {voice}
- Speed: {speed:+d}%
- Pitch: {pitch:+d}
- Language: {language}
"""

            # Generate simple cover image
            cover_path = self.generate_simple_cover(text[:50], tone)

            return (
                "‚úÖ Audiobook generated successfully! Click play to hear your text spoken clearly.",
                comparison,
                audio_file_path,  # For audio player
                audio_file_path,  # For download
                cover_path
            )

        except Exception as e:
            print(f"Processing error: {e}")
            return f"‚ùå Error: {str(e)}", "", None, None, None

    def summarize_text(self, text):
        """Simple text summarization"""
        sentences = text.split('.')
        if len(sentences) <= 3:
            return text

        # Take first, middle, and last sentences
        summary_sentences = [
            sentences[0],
            sentences[len(sentences)//2],
            sentences[-2] if sentences[-1].strip() == '' else sentences[-1]
        ]
        return '. '.join(s.strip() for s in summary_sentences if s.strip()) + '.'

    def generate_simple_cover(self, title, theme):
        """Generate a simple book cover"""
        try:
            width, height = 300, 400

            # Create gradient background based on theme
            img = Image.new('RGB', (width, height), color='white')
            draw = ImageDraw.Draw(img)

            # Color schemes for different themes
            colors = {
                "Suspenseful": [(30, 30, 60), (60, 30, 90)],
                "Inspiring": [(100, 150, 200), (150, 200, 255)],
                "Neutral": [(70, 100, 130), (130, 160, 190)]
            }

            theme_colors = colors.get(theme, colors["Neutral"])

            # Create gradient
            for i in range(height):
                r = int(theme_colors[0][0] + (theme_colors[1][0] - theme_colors[0][0]) * i / height)
                g = int(theme_colors[0][1] + (theme_colors[1][1] - theme_colors[0][1]) * i / height)
                b = int(theme_colors[0][2] + (theme_colors[1][2] - theme_colors[0][2]) * i / height)
                draw.rectangle([0, i, width, i+1], fill=(r, g, b))

            # Add title text
            try:
                font = ImageFont.truetype("arial.ttf", 24)
            except:
                font = ImageFont.load_default()

            # Wrap title text
            words = title.split()
            lines = []
            current_line = ""

            for word in words:
                if len(current_line + word) < 20:
                    current_line += word + " "
                else:
                    if current_line:
                        lines.append(current_line.strip())
                    current_line = word + " "
            if current_line:
                lines.append(current_line.strip())

            # Draw title
            y_offset = height // 3
            for line in lines:
                bbox = draw.textbbox((0, 0), line, font=font)
                text_width = bbox[2] - bbox[0]
                x = (width - text_width) // 2

                # Draw shadow
                draw.text((x+2, y_offset+2), line, fill='black', font=font)
                # Draw text
                draw.text((x, y_offset), line, fill='white', font=font)
                y_offset += 35

            # Add theme indicator
            draw.text((10, height-30), f"Tone: {theme}", fill='white', font=font)

            # Save cover
            cover_file = tempfile.NamedTemporaryFile(delete=False, suffix='.png')
            img.save(cover_file.name, 'PNG')
            cover_file.close()

            return cover_file.name

        except Exception as e:
            print(f"Cover generation error: {e}")
            return None

# ============================================================================
# GRADIO INTERFACE WITH WORKING AUDIO
# ============================================================================

def create_gradio_interface():
    app = AudiobookCreatorApp()

    with gr.Blocks(title="üéß AI Audiobook Creator - Clear Speech", theme=gr.themes.Soft()) as interface:

        gr.Markdown("""
        # üéß AI Audiobook Creator - Clear Speech Version

        Transform your text into audiobooks with **crystal clear speech synthesis**!

        ‚ú® **Features:**
        - üó£Ô∏è **Clear Speech Output** - Actual spoken words, not music
        - üé≠ **Multiple Voices** - Lisa (US), Michael (System), Allison (UK)
        - üìù **Tone Rewriting** - Neutral, Suspenseful, Inspiring
        - ‚ö° **Speed & Pitch Control** - Customize narration
        - üåç **Multi-language Support** - 5 languages supported
        """)

        with gr.Row():
            with gr.Column(scale=2):
                # Text Input
                gr.Markdown("### üìù Text Input")
                input_text = gr.Textbox(
                    label="Enter text to convert to speech",
                    placeholder="Type or paste your text here... (e.g., 'Hello, this is a test of the speech system. The quick brown fox jumps over the lazy dog.')",
                    lines=6,
                    value="Welcome to the AI Audiobook Creator! This system will convert your text into clear, natural-sounding speech. You can choose different voices and adjust the speed and pitch to create the perfect audiobook experience."
                )

                uploaded_file = gr.File(
                    label="Or upload a text file",
                    file_types=[".txt"],
                    type="binary"
                )

            with gr.Column(scale=1):
                # Voice Settings
                gr.Markdown("### üéôÔ∏è Voice Settings")

                voice = gr.Dropdown(
                    choices=["Lisa", "Michael", "Allison"],
                    value="Lisa",
                    label="üé≠ Voice Character",
                    info="Lisa: US Female, Michael: System Default, Allison: UK Female"
                )

                tone = gr.Dropdown(
                    choices=["Neutral", "Suspenseful", "Inspiring"],
                    value="Neutral",
                    label="‚úçÔ∏è Writing Tone",
                    info="How to rewrite the text"
                )

                with gr.Row():
                    speed = gr.Slider(
                        -30, 30, 0,
                        label="üèÉ Speed (%)",
                        info="Negative = slower, Positive = faster"
                    )
                    pitch = gr.Slider(
                        -10, 10, 0,
                        label="üéµ Pitch",
                        info="Negative = lower, Positive = higher"
                    )

                language = gr.Dropdown(
                    choices=list(Config.LANGUAGES.keys()),
                    value="English",
                    label="üåç Language"
                )

        # Options
        with gr.Accordion("üîß Additional Options", open=False):
            with gr.Row():
                add_music = gr.Checkbox(label="üéµ Background Music", value=False)
                emotion_mode = gr.Checkbox(label="üòä Emotion Mode", value=False)
                summarize_mode = gr.Checkbox(label="üìÑ Summarize Long Text", value=False)

        # Generate Button
        generate_btn = gr.Button(
            "üé¨ Generate Clear Speech Audiobook",
            variant="primary",
            size="lg"
        )

        # Output Section
        with gr.Row():
            with gr.Column():
                status_output = gr.Textbox(label="üìä Status", interactive=False)
                comparison_output = gr.Markdown(label="üìã Text Analysis")

            with gr.Column():
                audio_player = gr.Audio(
                    label="üéß Generated Audiobook (Click ‚ñ∂Ô∏è to play)",
                    type="filepath"
                )
                audio_download = gr.File(
                    label="üíæ Download Audio File",
                    type="filepath"
                )
                cover_image = gr.Image(
                    label="üìñ AI Generated Cover",
                    type="filepath"
                )

        # Quick Test Section
        with gr.Accordion("üöÄ Quick Test", open=True):
            gr.Markdown("### Try these sample texts to test the speech synthesis:")

            with gr.Row():
                sample_1 = gr.Button("üìö Sample Story", variant="secondary")
                sample_2 = gr.Button("üì∞ Sample News", variant="secondary")
                sample_3 = gr.Button("üé≠ Sample Drama", variant="secondary")

            def load_sample_story():
                return "Once upon a time, in a small village nestled between rolling hills and a crystal-clear stream, there lived a young girl named Elena. She had always been curious about the mysterious forest that bordered her town, where ancient trees whispered secrets in the wind."

            def load_sample_news():
                return "In a groundbreaking development, scientists have discovered a new method for generating clean energy that could revolutionize how we power our homes and cities. The innovative technology promises to reduce carbon emissions by up to fifty percent."

            def load_sample_drama():
                return "The door creaked open slowly, revealing nothing but darkness beyond. Sarah's heart pounded as she stepped forward, her flashlight cutting through the shadows. Something was waiting for her in the abandoned mansion, something that had been waiting for a very long time."

        # Usage Instructions
        with gr.Accordion("‚ÑπÔ∏è How to Use", open=False):
            gr.Markdown("""
            ### üìñ Instructions:

            1. **üìù Enter Text**: Type or paste your text in the input box, or upload a .txt file
            2. **üé≠ Choose Voice**: Select Lisa (US Female), Michael (System), or Allison (UK Female)
            3. **‚úçÔ∏è Select Tone**: Choose how to rewrite your text (Neutral, Suspenseful, Inspiring)
            4. **‚öôÔ∏è Adjust Settings**: Fine-tune speed and pitch to your preference
            5. **üé¨ Generate**: Click the generate button to create your audiobook
            6. **üéß Listen**: Use the audio player to hear your generated speech
            7. **üíæ Download**: Save the audio file to your device

            ### üîß Technical Notes:
            - Uses Google Text-to-Speech and pyttsx3 for clear speech
            - Supports multiple languages and voices
            - Audio output is WAV format for best quality
            - Text is automatically cleaned for optimal speech synthesis

            ### üí° Tips:
            - Keep text under 1000 characters for best performance
            - Use proper punctuation for natural pauses
            - Try different voices to find your preferred sound
            - Experiment with speed and pitch for the perfect narration
            """)

        # Event Handlers
        def process_generation(*args):
            return app.process_text_input(*args)

        # Connect main generation
        generate_btn.click(
            fn=process_generation,
            inputs=[
                input_text, uploaded_file, tone, voice, speed, pitch,
                language, add_music, emotion_mode, summarize_mode
            ],
            outputs=[
                status_output, comparison_output, audio_player,
                audio_download, cover_image
            ]
        )

        # Connect sample buttons
        sample_1.click(fn=load_sample_story, outputs=[input_text])
        sample_2.click(fn=load_sample_news, outputs=[input_text])
        sample_3.click(fn=load_sample_drama, outputs=[input_text])

    return interface

# ============================================================================
# LAUNCH APPLICATION
# ============================================================================

if __name__ == "__main__":
    print("""
    üéß AI Audiobook Creator - Clear Speech Setup:

    1. Install packages:
    !pip install gradio transformers torch pillow requests numpy
    !pip install pyttsx3 gtts pygame pydub
    !apt-get update && apt-get install espeak espeak-data libespeak1 libespeak-dev

    2. Launch application:
    The app will generate CLEAR SPEECH, not music tones!

    ‚úÖ Features:
    - Real text-to-speech synthesis
    - Multiple voice engines (GTTS, pyttsx3, espeak)
    - Clear word pronunciation
    - Adjustable speed and pitch
    - Working audio player and download
    """)

    # Create and launch
    interface = create_gradio_interface()
    interface.launch(
        share=True,
        debug=True,
        server_name="0.0.0.0",
        server_port=7860
    )

# INSTALLATION COMMANDS FOR GOOGLE COLAB
!pip install gradio transformers torch pillow requests numpy
!pip install pyttsx3 gtts pygame pydub
!apt-get update && apt-get install -y espeak espeak-data libespeak1 libespeak-dev festival festvox-kallpc16k
!pip install TTS